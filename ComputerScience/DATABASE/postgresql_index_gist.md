1. GiST Index
   GiST (Generalized Search Tree) index는 전체 텍스트를 고정 길이의 signature(비트 시퀀스)로 변환하여 저장한다. 그렇기 때문에 Gis 공간 데이터,기하학적 도형, 텍스트 검색, 유사성 검색 등 다양한 데이터 타입을 지원하는 범용 인덱스 구조이다.

- Gist index의 구조

Gist또한 트리 구조를 갖고있지만 B-tree와이 차이점은 B-tree는 키값이 순서에 따라 좌,우로 분기하는 반면 Gist는 `경계에 따라 분기`된다는 점이 다르다. Gist는 균형트리구조를 갖고있고 각 노드는 `경계값`을 갖고있다.

경계에 따른 분기? 경계값? 조금 더 알아보자

아래의 그림을 확인해보자 GiST의 내부 노드들이 있고 맨 아래 리프노드가 있다. 각 노드는 여러 개의 자식도드를 갖고있는데 상위 노드는 각 자식노드가 포함하는 데이터의 범위를 포함하고있다. 리프노드는 실제 데이터가 저장되는 위치를 가리킨다

full text search 검색에서 GiST 인덱스는 `tsvector` 데이터를 인덱싱한다.

각 문서는(하나의 row는) 단어들의 집합으로 표현되고 리프 노드에 저장된다. 내부 노드의 key는 자식 노드들의 단어 집합을 통합한 것이다. 경계 값을 기반으로 트리를 탐생한다.

문서는 signature로 비트맵 바이트로 변환되고 쿼리를 하는 데이터의 비트맵 변환과 비교하여 그 비슷한 범위를 찾아가는 방식으로 진행된다. 즉, 각 노드는 다신 노드들의 답어의 집합으로 되어있고 이것은 signature로 비트맵 바이트로 변환이 되어 저장된다.

이해를 위해 예시를 들어보자.

1. documents 테이블에 세 개의 데이터가 있다고 가정

- 'PostgreSQL is a powerful database.'
- 'Database management systems are important.'
- 'A powerful system provides high performance.'

2. `tsvector` 변환

- {'databas':5 'postgresql':1 'power':4}
- {'databas':1 'import':5 'manag':2 'system':3}
- {'high':5 'perform':6 'power':2 'provid':4 'system':3}

3. 리프 노드 생성

- 리프노드는 실제 데이터라고 위에서 언급했다
- 리프 노드 1: {'databas':5, 'postgresql':1, 'power':4}
- 리프 노드 2: {'databas':1, 'import':5, 'manag':2, 'system':3}
- 리프 노드 3: {'high':5, 'perform':6, 'power':2, 'provid':4, 'system':3}

4. 내부 노드 생성

- 리프 노드를 자식으로 갖는 내부 노드를 생성한다
- 내부 노드 A: 리프 노드 1과 리프 노드 2를 자식으로 갖는다
  키: {'databas', 'postgresql', 'power', 'manag', 'system', 'import'}
- 내부 노드 B: 리프 노드 3을 자식으로 갖는다
  키: {'high', 'perform', 'power', 'provid', 'system'}

5. 루트 노드 생성

- 내부 노드 A,B를 자식으로 갖고 이 내부 노드의 단어 집합을 합쳐서 키를 구성한다
- 키: 내부 노드 A,B의 단어 집합의 합집합인 {'databas', 'postgresql', 'power', 'manag', 'system', 'import', 'high', 'perform', 'provid'}

참고로 위에서 "signature로 비트맵 바이트로 변환" 되어 저장된다고 하였다. 각 단어는 해시 함수를 통해 비트 시그니처로 변환되어 키로 저장된다. 예를 들어 내부 노드의 비트 시그니처를 생성한다고 해보자. 리프노드의 {'databas', 'import', 'manag', 'system'}의 단어들을 비트 시그니처로 변환하여 비트맵을 형성한다. 리프노드1,2의 비트 시그니처를 OR 연산을 하여 내부 노드의 키를 생성하는 것이다. 이렇게 함으로써 고정된 크기를 유지하여 단어 집합의 크기에 영향을 받지 않을 수 있다.

- Gist Index 검색 과정
  질의로 'power'를 검색한다고 가정해보자. 질의의 비트 시그니처를 생성하고 루트 노드부터 시작하여 노드의 키와 비교한다.
  내부 노드의 비트맵이 쿼리 비트맵과 일치하거나 쿼리의 비트맵이 내부 노드의 비트맵에 포함되면 해당 내부 노드의 하위 노드를 계속 탐색한다. 리프 노드에 도달했을 때, 해당 리프 노드의 비트맵이 쿼리 비트맵과 일치하는지 확인한다. 만약 일치하면 해당 데이터가 검색 결과에 포함되고 그렇지 않다면 다음 경로를 계속 탐색한다.

이는 비트 시그니처를 사용하기 때문에 필요한 노드만 탐색하게 되어 속도가 빠르지만 비트 시그니처는 압축된 형태로 데이터를 표현하므로 Lossy특성(일부 정보가 손실될 수 있음)으로 정확한 데이터 구분이 어려울 수 있다는 단점이 있다. 다른 데이터가 동일한 비트위치에 매핑이 된다며 다른 단어이지만 일치한다고 잘못 판단할 수 있다.

Gist index는 정확도가 크게 중요하지 않는다면 삽입,삭제가 빈번한 경우 사용하는 것이 유리하다
