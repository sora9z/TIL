[⬅️ BACK ](./README.md)

## 데이터

### 1. 0과 1로 숫자를 표현하는 방법

- bit : 0과 1을 표현하는 가장 작은 정보 단위
  - 1 bit는 2^1, 2bit는 2^2 .. nbit는 2^n가지의 정보를 처리할 수 있다.
- byte = 8bit이다. 2^8
  - 1kB = 1000 byte
  - 1MB = 1000 Kb == 10^6 byte
  - 1GB = 1000 MB == 10^6 Kb == 10^9 byte
  - 1Tb = 1000Gb == 10^6 Gb == 10^9 Kb == 10^12 byte
  - 참고 1kB = 1024Byte 와 같은 표기는 KiB 와 같이 표기한다
- word : CPU가 한 번에 처리할 수 있는 데이터 크기. CPU가 처리할 수 있는 비트에 따라 워드는 달라질 수 있다.

  - 만약 cpu가 한 번에 32비트를 처리할 수 있다면 1 wor는 32bit가 된다.
  - intel x86 CPU 는 32비트 워드
  - intel x64 CPU 는 64비트 워드

- 이진법
  - 0과 1만으로 모든 숫자를 표현하는 방법
  - 숫자가 1을 넘어가는 시점에 자리 올림
  - 음수 표현
    - 2의보수
      - 어떤 수를 큰 2^n에서 뺀 값을 의미함
      - 11*(2)의 2의 보수는 큰 2^n 인 100*(2)에서 11*(2)를 뺀 01*(2)이 된다
      - 쉽게 하면 `모든 0과 1을 뒤집고 거기에 1을 더한 값 `으로 하면 됨
      - 음수인지 양수인지 구분하기 위해서 컴퓨터 내부에서는 플래그를 사용한다
- 십육진법
  - 15를 넘어가는 시점에 반올림을 한다
  - 10, 11, 12, 13, 14, 15, A, B, C, D, E, F
  - 코드상의 표기 ox15
  - 한 글자당 16 종류의 문자를 표현할 수 있다.
  - 16진수 한 글자를 4비트의 이진수로 간주할 수 있다. 2^4 = 16 이니까
  - 16진수를 2진수로 변환하는 방법은 16진수를 이루근 글자(4개의 글자)를 각각 이진수로 변환하고 그대로 이어붙이면 된다.
    - ex) 0x3A7F -> 0011 1010 0111 1111
  - 2진수를 16진수로 변환하는 방법은 2진수를 4비트씩 끊어서 16진수로 변환하면 된다.
    - ex) 0011 1010 0111 1111 -> 0x3A7F
  - 하드웨어와 밀접하게 관련인는 개발분야에서는 16진수와 이진수를 사용하는 경우도 있다
    - ex) 메모리 주소를 표현할 때 16진수를 사용한다.
    - ex) 컬러 코드를 표현할 때 16진수를 사용한다.
  - 이진수를 10진수로 표현하는것 보다 16진수로 표현하는 것이 더 간단하다.

### 2. 0과 1로 문자를 표현하는 방법

- 문자 집합과 인코딩

  - 문자 집합(charater set): 컴퓨터가 인식하고 표현할 수 있는 문자들의 모음이다.
    - 컴퓨터는 문자 집합에 속해있는 문자만 이해할 수 있다.
    - [컴퓨터] --- [문자집합] -- [사람]
  - 문자 인코딩(charater encoding): 문자 집합을 컴퓨터가 이해할 수 있는 0과 1로 변환하는 방법이다.
  - 문자 디코딩(charater decoding): 0과 1로 표현된 문자를 사람이 읽을 수 있는 문자로 변환하는 방법이다.

- 아스키 코드(ASCII) : America Standart Code for Information Interchange

  - https://namu.wiki/w/%EC%95%84%EC%8A%A4%ED%82%A4%20%EC%BD%94%EB%93%9C
  - 초창기 문자 집합 중 하나이다.
  - 영어 알파벳과 아라비아숫자, 일부 특수문자를 포함한다.
  - 7bit로 문자를 표현한다.
  - 2^7 = 128개의 문자를 표현할 수 있다.
  - 아스키 문자에 대응되는 수를 아스키 코드라고 한다. ex) A -> 65, a -> 97
  - 128개보다 많은 문자를 표현하지 못한다. 확장 아크키(Extended ASCII) 라고 아스키코드에 1비트를 추가하여 256개의 문자를 표현할 수 있도록 확장한 것이 있다.
  - 하지만 한국어를 포함한 영어권 이외는 표현하지 못한다.

- 한글 인코딩
  - 완성형 인코딩 : 하나의 글자에 고유한 코드 사용
  - 조합형 인코딩 : 초성, 중성, 종성으로 나누어 각각 코드를 사용
    - ex) 가 -> ㄱ(0x3131), ㅏ(0x314F)
  - ECU-KR
    - https://ko.wikipedia.org/wiki/EUC-KR
    - KS X 1001 , KS X 1003 표준을 따르는 인코딩 방식
    - 대표적인 완성형 인코딩 방식
    - 초성, 중성, 종성이 모두 결합된 2바이트 크기의 코드를 부여
    - ECU-KR로 인코딩된 한글은 16비트가 필요하다. 네 자리 16진수로 표현될 수 있다.
    - 하지만 모든 한글을 표현하지는 못한다
      - ex) 쀍 쀓 믜 등
  - CP949 (마이크로소프트)
    - ECU-KR의 확장된 버전
    - 그래도 넉넉한 양은 아니다.
- 유니코드와 UTF-8
  - 다국어를 지원하기 위한 문자 집합
  - ECU-KR 보다 다양한 한글을 포함
  - 화살표, 이모티콘까지
  - 각 문자마다 고유한 값이 부여된다.
    - ex) 한 -> D55C(16), 글 -> AE00(16)
  - 글자에 부여된 값 자체를 인코딩 된 글자로 사용하지 않고 이 값을 다양한 방법으로 인코딩 한다.
  - UTF-8은 유니코드를 인코딩하는 방법 중 하나이다.
    - 1바이크부터 4바이트까지 인코딩 결과를 만들어낸다
    - UTF-8인코딩 결과는 1바이크가 될 수도 4바이트가 될 수도 있다
      - 유니코드 문자에 부여된 값의 범위라 0~007F(16) 까지는 1바이트로 표현
      - 유니코드 문자에 부여된 값의 범위가 0080~07FF(16) 까지는 2바이트로 표현
      - 유니코드 문자에 부여된 값의 범위가 0800~FFFF(16) 까지는 3바이트로 표현
      - 유니코드 문자에 부여된 값의 범위가 10000~10FFFF(16) 까지는 4바이트로 표현
      - 한(D55C), 글(AE00)
        - 모두 0800~FFFF(16) 범위에 속하므로 3바이트로 표현된다
        - 1101 0101 0101 1100(2), 1010 1110 0000 0000(2)
