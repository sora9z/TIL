[⬅️ BACK ](./README.md)

# 03) 명령어

- 명령어란 무엇이고 어떻게 생겼으며 컴퓨터를 어떻게 작동시키는지 알아본다.

## 1. 소스코드와 명령어

- 작성한 소스코드가 컴퓨터 내부에서 명령어가 되고 실행되는 과정을 알아본다

### 고급언어와 저급언어

- 모든 소스코드는 컴퓨터 내부에서 명령어로 변환된다.
- 소스코드를 실행하기 위해 고급언어 -> 저급언어로 변환한다
- 고급언어(Hight-level programming language) :
  - 사람을 위한 언어
- 저급언어(Low-level programming language) :
  - 컴퓨터가 이해하고 실행할 수 있는 언어
  - 기계어(machine code) : 0,1의 명렁어 비트로 이루어짐. 16진수로 표현하기도 한다
  - 어셈블리어(assembly language) : 기계어를 읽기 편한 형태로 번역한 저급언어이다. 하드웨어와 밀접하게 맞닿아있는 개발자(임베지즈, 게임, 보안개발자 등)은 어셈블리어를 많이 시용한다.

### 커파일 언어와 인터프리터 언어

- 고급언어는 `어떻게` 저급언어로 변환이 될까? 두 가지 방법이 있다.

1. 컴파일언어

   - 컴파일 방식으로 작동하는 프로그래밍 언어
   - C, JAVA등이 대표적임
   - 컴파일러(컴파일을 수행해주는 도구. 오류확인, 오류 발견시 컴파일 실패)에 의해 소스코드가 저급언어로 변환되어 실행된다.
   - 저급언어로 변환된 것을 `목적코드` 라고 한다

2. 인터프리터언어

   - 인터프리트 방식으로 작동하는 프로그래밍 언어이다.
   - 대표적으로 python과 javascript가 있다
   - 인터프리터에 의해 소스코드가 한 줄씩 실행되는 고급언어이다.
   - 소스코드를 한 줄씩 실행하기 때문에 소스코드 전체를 저급언어로 변환하는 시간을 기다릴 필요가 없다.
     - 컴파일 변환 과정이 없기 때문에 바로바로 결과를 확인할 수 있다. 코드 수정도 빠르기 때문에 개발 속도가 빠르다. 반면 컴파일 언어는 코드르르 수정할 때마다 컴파일을 해야하므로 컴파일시간을 기다려야한다.
   - 하지만 일반적으로 컴파일언어보다 느리다. 저급언어로 변환된 목적코드는 컴퓨터가 바로 실행할 수 있지만 인터프리터 언어는 한 줄식 저급언어로 해석하며 실행해야하기 때문이다.
   - 인터프리터만 있으면 어디서나 실행이 가능하다. 예를들면 Python코드를 window에서 쓰다가 mac에서도 바로 실행할 수 있다.

3. 컴파일언어, 인터프리터 언어로 딱 구분이 되는가?

- python이라고 해서 컴파일을 하지 않는 것이 아니다. java또한 저급언어로 변환하는 과정에서 컴파일과 인터프리터를 동시에 수행한다.

### 목적파일 VS 실행파일

- 목적파일(Object File) :
  - 소스코드를 컴파일러가 컴파일해서 기계어로 변환한 파일이다.
  - 외부 라이브러리나 다른 소스코드와 연결되어있지 않았기 때문에 독립적으로 실행이 불가능하다
    - 예를 들면 import 등을 통해 라이브러리를 사용하는 경우, 다른 라이브러리에 의존성이 있는 경우
  - 링킹이라는 과정을 거쳐 실행파일로 만들어야한다.
- 링킹(Linking) :
  - 여러 목적파일과 라이브러리들을 하나의 실행파일로 결합하는 과정이다.
  - 링커(Linker)는 소스코드 간의 함수 호출, 변수 참조 같은 의존성을 해결하고 모든 코드가 올바르게 연결되도록 만든다.
  - 결과적으로 하나의 실행 가능한 파일을 생성한다.
- 실행파일(Executable File) :
  - 링킹이 완료된 후 생성되는 파일로, 운영체제에서 직접 실행할 수 있는 상태이다.
  - 프로그램을 실행할 때 필요한 모든 정보가 포함되어있다.

## 2. 명령어의 구조

- 명령어의 구조와 주소 지정방식을 학습
- 명령어의 작동 원리를 이해

### 연산 코드와 오퍼랜드

- 명령어는 연산자인 연산코드(Operation code) 피연산자인 오퍼랜드(Operand)로 구성됨

1. 오퍼랜드(Operand)

- 연산에 사용할 데이터 or 연산에 사용할 데이터가 저장된 위치의 주솟값(메모리 또는 레지스터)
- 오러팬드는 여러 개가 올 수 있다
- 오퍼랜드가 하나도 없으면 0-주소명령어, 1개있으면 1-주소명령어, 2개 있으면 2-주소명령어 등으로 불린다.
- 주소를 지저하는 경우도 많아서 `주소필드` 라고도 불린다.

2. 연산코드(Operation code)

- 명령어가 수행할 연산
- 기본적인 연산 코드유형 4가지

  - 데이터 전송
    - MOVE : 데이터를 옮겨라
    - STORE : 메모리에 저장하라
    - LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
    - PUSH : 스텍에 데이터를 저장하라
    - POP : 스텍 최상단의 데이터를 가져와라
  - 산술 논리 연산
    - ADD/SUBSTRACT/MULTIPLY/DIVIDE : 덧샘, 뺄샘, 곱하기, 나누기
    - INCREMENT / DECREMENT : 오퍼랜드를 더하라 빼라
    - AND/OR/NOT:AND/OR/NOT
    - COMPARE : 두 개의 숫자 또는 True,False 값을 비교하라
  - 제어 흐름 변경

    - JUMP : 특정 주소로 실행 순서 옮겨라
    - CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
    - HALT : 프로그램 실행을 멈춰라
    - CALL : 되돌아올 주소를 지정한태 특정 주소로 실행 순서를 옮겨라
    - RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라

  - 입출력 제어
    - READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
    - WRITE(OUTPUT) : 특정 입출력 장치로부터 데이터를 써라
    - START IO : 입출력 잘치를 시작하라
    - TTEST IO : 입출력 장치의 상태를 확인하라

### 주소 지정방식

- 주소 지정방식이란 연산에 사용할 데이터 위치를 찾는 방법이다.
- 오퍼랜드에 들어갈 데이터의 크기는 한정되어있다.
  - 만약 16비트의 명령어 크기에 연산코드가 4비트인 2-주소명령어의 경우 오퍼랜드 필드는 16-4 = 12 비트로 하나의 오퍼랜드는 6비트의 크기만 갖는다. 하나의 오퍼랜드에 2^6 의 가짓수의 정보만 저장이 가능하다.
- 만약 데이터가 아닌 데이터가 저장되어있는 주솟값이 들어가면 표현할 수 있는 데이터는 하나의 메모리공간만큼 커질 것이다.
  메모리주소대신 레지스터 이름으 들어가도 마찬가지이다.
- 연산의 대상이 되는 데이터가 저장된 위치를 `유효주소(Effective Address)`라고 한다

- 대표적인 주소지정방식 5가지
  - 즉시 주소 지정방싱(Immediate addressing mode)
    - 데이터를 오퍼랜드 필드에 직접 명시한다
    - 메모리 or 레지스터를 찾는 과정이 없어서 빠르다.
    - 표현할 수 있는 데이터의 크기가 한정적이다.
  - 직접 주소 지정방식(Direct addressing mode)
    - 오퍼랜드 필드에 유효 주소를 직접 명시하는 방법
    - 기럭장치 접근이 한번에이루어진다.
    - 표현 데이터 크기가 이전보다 커졌지만 유효주소 표현 범위에 한계가 있다.
  - 간접 주소 지정방식(Indirect addressing mode)
    - 유효 주소의 주소를 오퍼랜드 필드에 명시
    - 표현 가능한 유효주소의 범위가 더 넒어진다
    - 접근할 수 있는 기억장치 주소공간이 중앙처리장치가 한 번에 접근할 수 있는 단어의 길이로 결졍된다.
    - 두 번의 메모리 접근이 필요하다
    - 위의 두 경우보다 일반적으로 느리다
  - 레지스터 주소 지정방식(Register addressing mode)
    - 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법
    - 일반적으로 CPU 외부인 메모리보다 CPU내부에 있는 레지스터 접근이 더 빠르다.
    - 직접 주소 지정방식보다 빠르지만 표현할 수 있는 레지크터 크기제한이 생길 수 있다.
      - 레지스터의 수가 제한되어 있기 때문에 무한정 사용이 불가능하다
  - 레지스터 간접 주소지정 방식(Indirect register addressing mode)
    - 연산에 사용할 데이터를 메모리에 저장하고 그 주소(유효주소)를 저장한 레지스터를 오퍼랜드 필드에 명시
    - 유효주소를 찾는 과정이 간접주소지정방식과 비슷하지만 상대적으로 느린 메모리 접근 횟수가 한 번으로 줄어든다.
